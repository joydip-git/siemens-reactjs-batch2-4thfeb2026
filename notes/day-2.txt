component lifecycle:
-----------------------------
1. write code that should be executed when the component is mounted
2. write code that should be executed when the component receives new props  or internal state got updated
3. write code that should be executed everytime the component is rendered
4. write code that should be executed when the component is unmounted


function Test(props){
useEffect(
	()=>{
		//code
		sub
		return () => { //clean up code }
	}
)

useEffect(
	()=>{
		//code
		return () => { //clean up code }
	},
	[props.id, counter]
)

useEffect(
	()=>{
		//code
		return () => { //clean up code }
	},
	[]
)

	return ....
}

you want to pass data from one to another component:

a. components are nested into each other (shallow): props
b. components are nested into each other (deep): context
c. components are NOT nested into each other:
	1. sibling => rxJS, app-wide state management
	2. routed component: via routes, via rxjs, app-wide state management

Redux:
--------------
state => object
reducer => function 
store => oebject which is a collection of reducers (alog with the states)
dispatch => function (to send request to store)
action => object that is sent to the store using dispatch() function
	  contains one information: type of operation/action to perform on the state
		contains additional (optional) data
























function outer(){
	const x = 10

	function inner(){
		clg(x)
	}	
	return inner
}

const innerRef = outer() 
innerRef()

/home => Home
/     => Home

/products/all => PL
/products/view/{} => PD
/products/edit/{} => UP
/products/add => AP

* => PageNotFound

Route, Routes
<BrowserRouter>
	<Routes>
		<Route path='products' element={<PL />}/>
	</Routes>
</BrowserRouter>

const route:RouteObject = {
	path: 'products/all',
	element: <PL />
}

useRoutes([route])

BrowerRouter, HashRouter, MemoryRouter







